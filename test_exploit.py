"""
FinalFinal Test Suite
Automated tests for all exploit components
"""

import sys
import time
from pathlib import Path

import config
import utils
from modules import process_injector, pass_the_hash, network_scanner, lateral_movement

logger = utils.setup_logging("TestSuite")


class TestSuite:
    """Test suite for FinalFinal exploit framework"""
    
    def __init__(self):
        """Initialize test suite"""
        self.tests_passed = 0
        self.tests_failed = 0
        self.tests_total = 0
    
    def run_test(self, test_name: str, test_func) -> bool:
        """
        Run a single test
        
        Args:
            test_name: Name of the test
            test_func: Test function to execute
            
        Returns:
            True if test passed, False otherwise
        """
        self.tests_total += 1
        
        try:
            utils.print_info(f"Running: {test_name}")
            test_func()
            utils.print_success(f"✓ PASSED: {test_name}")
            self.tests_passed += 1
            return True
        except Exception as e:
            utils.print_error(f"✗ FAILED: {test_name}")
            logger.error(f"Test failed: {e}")
            self.tests_failed += 1
            return False
    
    def test_config_safety(self):
        """Test that safety settings are properly configured"""
        assert config.RESEARCH_MODE == True, "RESEARCH_MODE must be True"
        assert config.LOCALHOST_ONLY == True, "LOCALHOST_ONLY must be True"
        assert config.SIMULATE_INJECTION == True, "SIMULATE_INJECTION must be True"
        assert config.C2_HOST in ["127.0.0.1", "localhost"], "C2_HOST must be localhost"
    
    def test_encryption(self):
        """Test encryption and decryption"""
        test_data = b"TEST_DATA_FOR_ENCRYPTION"
        
        # Encrypt
        encrypted, iv = utils.encrypt_data(test_data)
        assert len(encrypted) > 0, "Encryption failed"
        
        # Decrypt
        decrypted = utils.decrypt_data(encrypted, iv)
        assert decrypted == test_data, "Decryption failed"
    
    def test_hashing(self):
        """Test hashing functions"""
        test_data = b"TEST_DATA_FOR_HASHING"
        
        # Calculate hash
        hash_value = utils.calculate_hash(test_data)
        assert len(hash_value) == 64, "SHA256 hash should be 64 characters"
        
        # Verify hash
        assert utils.verify_hash(test_data, hash_value), "Hash verification failed"
    
    def test_encoding(self):
        """Test encoding functions"""
        test_data = b"TEST_DATA_FOR_ENCODING"
        
        # Base64
        encoded = utils.encode_base64(test_data)
        decoded = utils.decode_base64(encoded)
        assert decoded == test_data, "Base64 encoding/decoding failed"
        
        # Hex
        hex_str = utils.bytes_to_hex(test_data)
        bytes_data = utils.hex_to_bytes(hex_str)
        assert bytes_data == test_data, "Hex encoding/decoding failed"
    
    def test_process_injector(self):
        """Test process injector module"""
        injector = process_injector.ProcessInjector()
        
        # Test finding process
        pid = injector.find_target_process("mspaint.exe")
        assert pid is not None, "Failed to find target process"
        
        # Test injection
        shellcode = b"DEMO_SHELLCODE"
        result = injector.inject_shellcode(pid, shellcode)
        assert result == True, "Injection simulation failed"
    
    def test_pass_the_hash(self):
        """Test pass-the-hash module"""
        pth = pass_the_hash.PassTheHashModule()
        
        # Test LSASS dump
        result = pth.dump_lsass_memory()
        assert result == True, "LSASS dump simulation failed"
        
        # Test credentials
        creds = pth.list_credentials()
        assert len(creds) > 0, "No credentials extracted"
        
        # Test pass-the-hash
        result = pth.pass_the_hash_attack(
            "192.168.1.100",
            "Administrator",
            "aad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0",
            "DOMAIN"
        )
        assert result == True, "Pass-the-hash simulation failed"
    
    def test_network_scanner(self):
        """Test network scanner module"""
        scanner = network_scanner.NetworkScanner()
        
        # Test ping sweep
        hosts = scanner.ping_sweep("192.168.1.0/24")
        assert len(hosts) > 0, "Ping sweep found no hosts"
        
        # Test port scan
        ports = scanner.port_scan("192.168.1.100")
        assert len(ports) > 0, "Port scan found no open ports"
        
        # Test SMB enumeration
        smb_info = scanner.smb_enumeration("192.168.1.100")
        assert 'shares' in smb_info, "SMB enumeration failed"
    
    def test_lateral_movement(self):
        """Test lateral movement module"""
        lm = lateral_movement.LateralMovementModule()
        
        # Test PSExec
        result = lm.psexec_lateral_movement(
            "192.168.1.100",
            "Administrator",
            ntlm_hash="aad3b435b51404ee..."
        )
        assert result == True, "PSExec simulation failed"
        
        # Test WMI
        result = lm.wmi_lateral_movement(
            "192.168.1.101",
            "Administrator",
            password="P@ssw0rd"
        )
        assert result == True, "WMI simulation failed"
        
        # Check compromised hosts
        hosts = lm.list_compromised_hosts()
        assert len(hosts) > 0, "No hosts compromised"
    
    def test_shellcode_generation(self):
        """Test shellcode generation"""
        from shellcode_generator import ShellcodeGenerator
        
        output_path = "payloads/test_payload.bin"
        generator = ShellcodeGenerator(output_path, "x64")
        
        # Generate shellcode
        shellcode = generator.generate_demo_shellcode()
        assert len(shellcode) > 0, "Shellcode generation failed"
        
        # Encrypt shellcode
        encrypted, iv, key = generator.encrypt_shellcode(shellcode)
        assert len(encrypted) > 0, "Shellcode encryption failed"
    
    def test_implant_id_generation(self):
        """Test implant ID generation"""
        id1 = utils.generate_implant_id()
        id2 = utils.generate_implant_id()
        
        assert len(id1) == 16, "Implant ID should be 16 characters"
        assert id1 != id2, "Implant IDs should be unique"
    
    def test_jitter_calculation(self):
        """Test jitter calculation"""
        interval = 60
        jittered = utils.calculate_jitter(interval, 20)
        
        # Should be within 20% of original
        min_val = interval - (interval * 0.2)
        max_val = interval + (interval * 0.2)
        
        assert min_val <= jittered <= max_val, "Jitter calculation out of range"
    
    def run_all_tests(self):
        """Run all tests"""
        utils.print_banner()
        utils.print_info("FinalFinal Test Suite")
        utils.print_info("Running automated tests...\n")
        
        # Safety check
        utils.check_safety_mode()
        
        # Run tests
        tests = [
            ("Configuration Safety", self.test_config_safety),
            ("Encryption/Decryption", self.test_encryption),
            ("Hashing Functions", self.test_hashing),
            ("Encoding Functions", self.test_encoding),
            ("Process Injector", self.test_process_injector),
            ("Pass-the-Hash", self.test_pass_the_hash),
            ("Network Scanner", self.test_network_scanner),
            ("Lateral Movement", self.test_lateral_movement),
            ("Shellcode Generation", self.test_shellcode_generation),
            ("Implant ID Generation", self.test_implant_id_generation),
            ("Jitter Calculation", self.test_jitter_calculation)
        ]
        
        for test_name, test_func in tests:
            self.run_test(test_name, test_func)
            time.sleep(0.5)
        
        # Print summary
        self.print_summary()
    
    def print_summary(self):
        """Print test summary"""
        print(f"\n{utils.Fore.YELLOW}{'='*70}")
        print("TEST SUMMARY")
        print(f"{'='*70}{utils.Style.RESET_ALL}\n")
        
        print(f"Total Tests: {self.tests_total}")
        print(f"{utils.Fore.GREEN}Passed: {self.tests_passed}{utils.Style.RESET_ALL}")
        
        if self.tests_failed > 0:
            print(f"{utils.Fore.RED}Failed: {self.tests_failed}{utils.Style.RESET_ALL}")
        else:
            print(f"Failed: {self.tests_failed}")
        
        success_rate = (self.tests_passed / self.tests_total * 100) if self.tests_total > 0 else 0
        print(f"\nSuccess Rate: {success_rate:.1f}%")
        
        if self.tests_failed == 0:
            utils.print_success("\n✓ All tests passed!")
        else:
            utils.print_error(f"\n✗ {self.tests_failed} test(s) failed")


def main():
    """Main entry point"""
    test_suite = TestSuite()
    test_suite.run_all_tests()
    
    # Exit with appropriate code
    sys.exit(0 if test_suite.tests_failed == 0 else 1)


if __name__ == "__main__":
    main()
